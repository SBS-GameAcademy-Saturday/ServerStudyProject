using System;
using System.Threading;

namespace ServerCore
{
    /*
     * ============================================================================
     * Class 1. 멀티스레드 개론
     * ============================================================================
     * 
     * [1] 멀티스레드(Multi-Thread)란?
     * 
     *    정의: 하나의 프로그램 안에서 여러 작업을 동시에 실행하는 기술
     *    Thread = 실행의 흐름 = "일꾼"
     * 
     * 
     * [2] 실생활 비유
     * 
     *    싱글스레드 식당:
     *    ┌──────────┐
     *    │ 요리사 1명 │ → 손님1 요리 → 손님2 요리 → 손님3 요리
     *    └──────────┘
     *    결과: 손님들이 오래 기다림 (1시간씩)
     * 
     *    멀티스레드 식당:
     *    ┌──────────┐
     *    │ 요리사 1  │ → 손님1 요리
     *    ├──────────┤
     *    │ 요리사 2  │ → 손님2 요리  (동시 진행!)
     *    ├──────────┤
     *    │ 요리사 3  │ → 손님3 요리
     *    └──────────┘
     *    결과: 빠르게 서비스 제공 (20분)
     * 
     * 
     * [3] 게임 서버에서 왜 필요한가?
     * 
     *    상황: MMORPG 게임 서버, 동시 접속자 10,000명
     *    
     *    플레이어A: 몬스터 공격 요청 → 데미지 계산
     *    플레이어B: 아이템 획득 요청 → DB에 저장
     *    플레이어C: 채팅 메시지 전송 → 다른 플레이어에게 전달
     *    플레이어D: 캐릭터 이동 요청 → 위치 업데이트
     *    ... (10,000명의 요청이 동시에!)
     *    
     *    싱글스레드로 처리한다면?
     *    - 한 명씩 순서대로 처리
     *    - 한 명당 1ms(0.001초)만 걸려도 10,000명 = 10초!
     *    - 10초 뒤에 처리? → 게임 플레이 불가능
     *    
     *    멀티스레드로 처리한다면?
     *    - 여러 플레이어를 동시에 처리
     *    - 응답 속도 대폭 향상!
     * 
     * 
     * [4] 프로세스 vs 스레드
     * 
     *    프로세스(Process):
     *    - 실행 중인 프로그램 하나
     *    - 독립적인 메모리 공간 사용
     *    - 예: 게임 클라이언트.exe, 게임 서버.exe
     *    
     *    스레드(Thread):
     *    - 프로세스 안에서 실행되는 작업 흐름
     *    - 같은 프로세스의 스레드들은 메모리를 공유
     *    - 예: 네트워크 처리 스레드, DB 처리 스레드
     *    
     *    구조:
     *    ┌─────────────────────────────────┐
     *    │      게임 서버 프로세스          │
     *    │                                 │
     *    │  ┌─────────┐  ┌─────────┐      │
     *    │  │Thread 1 │  │Thread 2 │      │
     *    │  │네트워크  │  │DB 처리  │      │
     *    │  └─────────┘  └─────────┘      │
     *    │                                 │
     *    │  ┌─────────┐  ┌─────────┐      │
     *    │  │Thread 3 │  │Thread 4 │      │
     *    │  │게임로직  │  │채팅처리 │      │
     *    │  └─────────┘  └─────────┘      │
     *    │                                 │
     *    │    [공유 메모리 영역]             │
     *    │   - 플레이어 정보                │
     *    │   - 게임 월드 데이터             │
     *    │   - 몬스터 정보                  │
     *    └─────────────────────────────────┘
     * 
     * 
     * [5] 멀티스레드의 장단점
     * 
     *    장점:
     *    ✅ 속도 향상: 여러 작업을 동시에 처리
     *    ✅ 응답성: 하나의 작업이 느려도 다른 작업은 계속 진행
     *    ✅ 자원 공유: 메모리를 공유해서 효율적
     *    
     *    단점:
     *    ❌ 동기화 문제: 여러 스레드가 같은 데이터를 동시에 수정하면 버그
     *    ❌ 디버깅 어려움: 타이밍에 따라 버그가 발생하거나 안 하거나
     *    ❌ 복잡도 증가: 코드가 복잡해짐
     * 
     * 
     * [6] 핵심 용어 정리
     * 
     *    Thread(스레드): 프로그램 실행의 최소 단위, "일꾼"
     *    Main Thread: 프로그램이 시작될 때 자동으로 생성되는 기본 스레드
     *    Worker Thread: 작업을 처리하기 위해 추가로 생성하는 스레드
     *    Thread ID: 각 스레드를 구분하는 고유 번호
     *    Join(): 다른 스레드가 끝날 때까지 기다리는 함수
     *    Sleep(): 스레드를 일정 시간 동안 멈추는 함수
     */

    static class Program
    {
        /*
         * ========================================
         * 싱글스레드 테스트
         * ========================================
         * 
         * 목적: 작업을 순차적으로 처리했을 때의 시간 측정
         * 
         * 동작 방식:
         * 1. 5개의 작업을 하나씩 순서대로 실행
         * 2. 각 작업은 1초가 걸림
         * 3. 총 소요시간 = 1초 × 5개 = 5초
         * 
         * 실행 흐름:
         * [Main Thread]
         * 작업1 실행 (1초) → 작업2 실행 (1초) → 작업3 실행 (1초) → 작업4 실행 (1초) → 작업5 실행 (1초)
         * |---------|---------|---------|---------|---------|
         * 0초       1초       2초       3초       4초       5초
         */
        static void SingleThreadTest()
        {
            Console.WriteLine("=== 싱글스레드 테스트 시작 ===");
            
            // 시작 시간 기록
            DateTime start = DateTime.Now;
            
            // 5개의 작업을 순서대로 처리
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine($"작업 {i + 1} 실행 중...");
                
                // Thread.Sleep(밀리초): 현재 스레드를 지정한 시간만큼 멈춤
                // 1000밀리초 = 1초
                // 실제 게임 서버에서는: DB 쿼리, 네트워크 응답 대기 등
                Thread.Sleep(1000);
                
                Console.WriteLine($"작업 {i + 1} 완료!");
            }
            
            // 끝난 시간 - 시작 시간 = 총 소요 시간
            TimeSpan elapsed = DateTime.Now - start;
            Console.WriteLine($"총 소요시간: {elapsed.TotalSeconds}초\n");
            
            // 예상 결과: 약 5초
            // 설명: 5개 작업을 순차적으로 처리했으므로 1초 × 5 = 5초
        }

        /*
         * ========================================
         * 멀티스레드 테스트
         * ========================================
         * 
         * 목적: 작업을 동시에 처리했을 때의 시간 측정
         * 
         * 동작 방식:
         * 1. 5개의 스레드를 생성
         * 2. 각 스레드에서 1초 걸리는 작업 실행
         * 3. 모든 스레드가 동시에 실행됨
         * 4. 총 소요시간 = 1초 (가장 긴 작업의 시간)
         * 
         * 실행 흐름:
         * [Thread 1] 작업1 실행 (1초) →
         * [Thread 2] 작업2 실행 (1초) →
         * [Thread 3] 작업3 실행 (1초) →  ← 동시에 실행!
         * [Thread 4] 작업4 실행 (1초) →
         * [Thread 5] 작업5 실행 (1초) →
         * |---------|
         * 0초       1초
         * 
         * 핵심 차이점:
         * - 싱글: 5개 작업을 차례대로 = 5초
         * - 멀티: 5개 작업을 동시에 = 1초 (5배 빠름!)
         */
        static void MultiThreadTest()
        {
            Console.WriteLine("=== 멀티스레드 테스트 시작 ===");
            
            // 시작 시간 기록
            DateTime start = DateTime.Now;
            
            // 5개의 스레드를 저장할 배열 선언
            // Thread[]: 여러 개의 스레드를 관리하기 위한 배열
            Thread[] threads = new Thread[5];
            
            // 5개의 스레드 생성 및 시작
            for (int i = 0; i < 5; i++)
            {
                /*
                 * [중요!] 클로저(Closure) 문제
                 * 
                 * 잘못된 코드:
                 * threads[i] = new Thread(() => {
                 *     Console.WriteLine($"작업 {i + 1}");  // 버그! i 값이 변함
                 * });
                 * 
                 * 문제:
                 * - 람다식 내부에서 외부 변수 i를 참조
                 * - 스레드가 실행될 때 i 값이 이미 변경되어 있을 수 있음
                 * - 결과: "작업 6", "작업 6", "작업 6" 같은 이상한 출력
                 * 
                 * 해결:
                 * - 지역 변수 taskId에 현재 i 값을 복사
                 * - 각 스레드가 자신만의 taskId를 가짐
                 * - 결과: 정확한 출력 보장
                 */
                int taskId = i;  // 현재 i 값을 고정 (클로저 문제 해결)
                
                /*
                 * new Thread(실행할코드):
                 * - 새로운 스레드 생성
                 * - 괄호 안의 코드를 별도의 스레드에서 실행
                 * 
                 * 람다식 () => { ... }:
                 * - 익명 함수 (이름 없는 함수)
                 * - 간단한 코드를 전달할 때 사용
                 */
                threads[i] = new Thread(() =>
                {
                    /*
                     * Thread.CurrentThread:
                     * - 현재 실행 중인 스레드 정보
                     * 
                     * ManagedThreadId:
                     * - .NET에서 관리하는 스레드 고유 번호
                     * - 1, 2, 3, 4, ... 같은 숫자
                     * - 디버깅할 때 어떤 스레드인지 구분하는 용도
                     */
                    int threadId = Thread.CurrentThread.ManagedThreadId;
                    
                    Console.WriteLine($"작업 {taskId + 1} 실행 중... (ThreadID: {threadId})");
                    
                    // 1초 걸리는 작업 시뮬레이션
                    Thread.Sleep(1000);
                    
                    Console.WriteLine($"작업 {taskId + 1} 완료!");
                });
                
                /*
                 * Start():
                 * - 스레드 실행 시작
                 * - 이 함수를 호출하면 즉시 반환됨 (기다리지 않음)
                 * - 실제 작업은 백그라운드에서 진행
                 * 
                 * 중요:
                 * - Start()만 호출하면 Main이 먼저 끝날 수 있음!
                 * - Join()을 사용해서 스레드가 끝날 때까지 기다려야 함
                 */
                threads[i].Start();
            }
            
            /*
             * Join():
             * - "이 스레드가 끝날 때까지 기다려!"
             * - 호출한 스레드(Main)는 여기서 멈춤
             * - 해당 스레드가 끝나면 계속 진행
             * 
             * 왜 필요한가?
             * 
             * Join() 없으면:
             * Main → 스레드들 시작 → 바로 "총 소요시간" 출력 → 프로그램 종료
             *     → 스레드들이 끝나기도 전에 프로그램이 꺼짐!
             * 
             * Join() 있으면:
             * Main → 스레드들 시작 → 모든 스레드 끝날 때까지 대기 
             *     → "총 소요시간" 출력 → 프로그램 종료
             * 
             * 실행 흐름:
             * [Main Thread]
             * threads[0].Start() → 
             * threads[1].Start() → 
             * threads[2].Start() → 
             * threads[3].Start() → 
             * threads[4].Start() → 
             * threads[0].Join() → [대기]
             *                   ↓
             *              [Thread 0 완료]
             *                   ↓
             * threads[1].Join() → [대기]
             *                   ↓
             *              [Thread 1 완료]
             * ... (모든 스레드 완료 대기)
             */
            foreach (var thread in threads)
            {
                thread.Join();  // 각 스레드가 끝날 때까지 대기
            }
            
            // 모든 스레드가 끝난 후 시간 계산
            TimeSpan elapsed = DateTime.Now - start;
            Console.WriteLine($"총 소요시간: {elapsed.TotalSeconds}초\n");
            
            // 예상 결과: 약 1초
            // 설명: 5개 작업이 동시에 실행되므로 가장 긴 작업(1초)만큼만 걸림
        }

        /*
         * ========================================
         * Main 함수
         * ========================================
         * 
         * 프로그램 시작점
         * - 모든 C# 프로그램은 Main 함수에서 시작
         * - Main 함수도 하나의 스레드에서 실행됨 = Main Thread
         */
        static void Main(string[] args)
        {
            /*
             * 성능 비교 테스트
             * 
             * 목적:
             * 1. 싱글스레드와 멀티스레드의 속도 차이 확인
             * 2. 멀티스레드가 왜 필요한지 체감
             */
            
            // 테스트 1: 싱글스레드 (예상: 5초)
            SingleThreadTest();
            
            // 테스트 2: 멀티스레드 (예상: 1초)
            MultiThreadTest();
            
            /*
             * Main Thread ID 확인
             * 
             * - Main 함수도 스레드에서 실행됨
             * - 일반적으로 ThreadID = 1
             * - 나머지 스레드들은 2, 3, 4, ... 순서로 번호 부여
             */
            Console.WriteLine($"\nMain Thread ID: {Thread.CurrentThread.ManagedThreadId}");
            Console.WriteLine("프로그램 종료");
            
            /*
             * ========================================
             * 실행 결과 예시
             * ========================================
             * 
             * === 싱글스레드 테스트 시작 ===
             * 작업 1 실행 중...
             * 작업 1 완료!
             * 작업 2 실행 중...
             * 작업 2 완료!
             * 작업 3 실행 중...
             * 작업 3 완료!
             * 작업 4 실행 중...
             * 작업 4 완료!
             * 작업 5 실행 중...
             * 작업 5 완료!
             * 총 소요시간: 5.002초
             * 
             * === 멀티스레드 테스트 시작 ===
             * 작업 1 실행 중... (ThreadID: 4)
             * 작업 3 실행 중... (ThreadID: 6)
             * 작업 2 실행 중... (ThreadID: 5)
             * 작업 5 실행 중... (ThreadID: 8)
             * 작업 4 실행 중... (ThreadID: 7)
             * 작업 1 완료!
             * 작업 2 완료!
             * 작업 3 완료!
             * 작업 5 완료!
             * 작업 4 완료!
             * 총 소요시간: 1.003초
             * 
             * Main Thread ID: 1
             * 프로그램 종료
             * 
             * 
             * ========================================
             * 핵심 정리
             * ========================================
             * 
             * 1. Thread 생성: new Thread(실행할메서드)
             * 2. Thread 시작: thread.Start()
             * 3. Thread 대기: thread.Join()
             * 4. Thread ID: Thread.CurrentThread.ManagedThreadId
             * 5. 멀티스레드 = 여러 작업을 동시에 = 빠름!
             * 
             * 
             * ========================================
             * 다음 강의 예고
             * ========================================
             * 
             * Class 2. 쓰레드 생성
             * - Thread, ThreadPool, Task의 차이
             * - 어떤 방식을 언제 사용해야 하는가?
             * - 반환값이 있는 작업 처리
             */
        }
    }
}