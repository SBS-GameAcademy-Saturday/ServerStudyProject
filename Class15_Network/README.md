# 📘 Network Programming (네트워크 프로그래밍)

## Class 19. 네트워크 기초 이론

### 1. 네트워크란?

**정의**
- 두 개 이상의 컴퓨터가 연결되어 데이터를 주고받는 통신 시스템
- "Network" = Net (그물) + Work (작업)
- 여러 노드(Node)가 연결된 그물망 구조

**게임 서버 관점**
```
┌─────────┐     ┌─────────┐     ┌─────────┐
│ Client1 │────▶│  Game   │◀────│ Client2 │
└─────────┘     │ Server  │     └─────────┘
                └─────────┘
                     ▲
                     │
                ┌─────────┐
                │ Client3 │
                └─────────┘
```

---

### 2. OSI 7계층 모델

**OSI (Open Systems Interconnection) 7계층**

```
┌─────────────────────────────────────────┐
│ 7. Application Layer (응용 계층)         │
│    - HTTP, FTP, SMTP, DNS               │
│    - 사용자 응용 프로그램                 │
├─────────────────────────────────────────┤
│ 6. Presentation Layer (표현 계층)        │
│    - 데이터 암호화, 압축, 인코딩          │
│    - SSL/TLS                            │
├─────────────────────────────────────────┤
│ 5. Session Layer (세션 계층)             │
│    - 연결 설정, 유지, 종료               │
│    - 동기화, 체크포인트                  │
├─────────────────────────────────────────┤
│ 4. Transport Layer (전송 계층)           │
│    - TCP, UDP                           │
│    - 포트 번호, 신뢰성 보장              │  ← 게임 서버 핵심!
├─────────────────────────────────────────┤
│ 3. Network Layer (네트워크 계층)         │
│    - IP (Internet Protocol)             │
│    - 라우팅, IP 주소                    │
├─────────────────────────────────────────┤
│ 2. Data Link Layer (데이터 링크 계층)    │
│    - MAC 주소, 이더넷                   │
│    - 프레임 전송                        │
├─────────────────────────────────────────┤
│ 1. Physical Layer (물리 계층)            │
│    - 전기 신호, 케이블                  │
│    - 비트 전송                          │
└─────────────────────────────────────────┘
```

**실제 사용 (TCP/IP 4계층)**

게임 서버에서는 주로 **TCP/IP 4계층 모델** 사용:

```
┌──────────────────────────────┐
│ Application Layer            │
│ (OSI 5, 6, 7 통합)           │  ← 게임 로직, 패킷 처리
│ - HTTP, Game Protocol        │
├──────────────────────────────┤
│ Transport Layer              │
│ (OSI 4)                      │  ← TCP / UDP
│ - TCP, UDP                   │
├──────────────────────────────┤
│ Internet Layer               │
│ (OSI 3)                      │  ← IP 주소
│ - IP, ICMP, ARP              │
├──────────────────────────────┤
│ Network Access Layer         │
│ (OSI 1, 2 통합)              │  ← 하드웨어
│ - Ethernet, Wi-Fi            │
└──────────────────────────────┘
```

---

### 3. IP 주소

**IPv4 (Internet Protocol version 4)**

구조:
- 32비트 (4바이트)
- 0.0.0.0 ~ 255.255.255.255
- 점으로 구분된 10진수 표기

예시:
```
192.168.0.1
│   │   │ │
│   │   │ └─ 호스트 부분
│   │   └─── 호스트 부분
│   └─────── 네트워크 부분
└─────────── 네트워크 부분
```

**특수 IP 주소**
```
127.0.0.1         - Loopback (자기 자신)
                    localhost
                    게임 클라이언트-서버 로컬 테스트

0.0.0.0           - 모든 인터페이스
                    서버가 모든 IP에서 수신 대기

192.168.x.x       - 사설 IP (Private IP)
10.x.x.x            LAN 내부에서만 사용
172.16~31.x.x       공인 IP 필요 시 NAT

255.255.255.255   - 브로드캐스트
                    같은 네트워크 모든 호스트
```

**IPv6**
- 128비트
- 주소 고갈 문제 해결
- 예: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`

---

### 4. 포트 (Port)

**정의**
- IP 주소 내에서 특정 프로세스를 식별하는 번호
- 16비트 (0 ~ 65535)

**비유**
```
IP 주소 = 아파트 주소
포트 = 동/호수

192.168.0.1:7777
│           │
IP 주소     포트
```

**포트 범위**
```
0 ~ 1023        - Well-Known Ports
                  시스템 예약
                  예: 80 (HTTP), 443 (HTTPS), 22 (SSH)

1024 ~ 49151    - Registered Ports
                  응용 프로그램 등록
                  예: 3306 (MySQL), 5432 (PostgreSQL)

49152 ~ 65535   - Dynamic Ports
                  임시 포트
                  클라이언트가 자동 할당
```

**게임 서버 예시**
```
게임 서버: 192.168.0.100:7777
│                         │
서버 IP                   게임 포트

클라이언트 1: 192.168.0.50:52341  ────┐
클라이언트 2: 192.168.0.51:52342  ────┼──▶ 서버:7777
클라이언트 3: 192.168.0.52:52343  ────┘
                          ▲
                          임시 포트 (자동 할당)
```

---

### 5. 소켓 (Socket)

**정의**
- 네트워크 통신의 끝점 (Endpoint)
- IP 주소 + 포트 번호
- "소켓" = 플러그처럼 연결하는 지점

**구조**
```
Socket = IP Address + Port Number + Protocol

예시:
TCP Socket: 192.168.0.1:7777 (TCP)
UDP Socket: 192.168.0.1:7778 (UDP)
```

**소켓 통신 과정**

```
서버                              클라이언트
│                                 │
│ socket() ◀────────────────────▶ │ socket()
│ (소켓 생성)                      │ (소켓 생성)
│                                 │
│ bind()                          │
│ (IP:Port 바인딩)                 │
│                                 │
│ listen()                        │
│ (연결 대기)                      │
│                                 │
│                                 │ connect()
│                                 │ (연결 요청)
│ accept() ◀──────────────────────┤
│ (연결 수락)                      │
│                                 │
├─────────── 연결 수립 ────────────┤
│                                 │
│ send()/recv() ◀────────────────▶ send()/recv()
│ (데이터 송수신)                  │ (데이터 송수신)
│                                 │
│ close() ◀──────────────────────▶ close()
│ (연결 종료)                      │ (연결 종료)
```

---

### 6. TCP vs UDP

**TCP (Transmission Control Protocol)**

특징:
- ✅ 연결 지향 (Connection-oriented)
- ✅ 신뢰성 보장 (데이터 손실 없음)
- ✅ 순서 보장 (패킷 순서대로 도착)
- ✅ 흐름 제어, 혼잡 제어
- ❌ 느림 (오버헤드 큼)
- ❌ 1:1 통신만 가능

사용 예:
- 웹 브라우징 (HTTP/HTTPS)
- 이메일 (SMTP)
- 파일 전송 (FTP)
- **턴제 게임, MMORPG 로그인/채팅**

```
클라이언트                    서버
    │                         │
    ├─── SYN ────────────────▶│ 1. 연결 요청
    │                         │
    │◀─── SYN-ACK ────────────┤ 2. 연결 수락
    │                         │
    ├─── ACK ────────────────▶│ 3. 연결 확인
    │                         │
    ├═════ 데이터 송수신 ═════╪═
    │                         │
```

**UDP (User Datagram Protocol)**

특징:
- ✅ 비연결 지향 (Connectionless)
- ✅ 빠름 (오버헤드 적음)
- ✅ 1:1, 1:N, N:N 통신 가능
- ❌ 신뢰성 없음 (패킷 손실 가능)
- ❌ 순서 보장 없음
- ❌ 흐름 제어 없음

사용 예:
- 실시간 스트리밍 (음성, 영상)
- DNS 조회
- **FPS, 레이싱 게임 (실시간 위치 동기화)**

```
클라이언트                    서버
    │                         │
    ├─── 데이터 ─────────────▶│
    │                         │
    ├─── 데이터 ─────────────▶│
    │     ✗ (패킷 손실)        │
    ├─── 데이터 ─────────────▶│
    │                         │
```

**비교표**

| 특성 | TCP | UDP |
|------|-----|-----|
| 연결 | 연결 지향 | 비연결 |
| 신뢰성 | 보장 | 보장 안 함 |
| 순서 | 보장 | 보장 안 함 |
| 속도 | 느림 | 빠름 |
| 오버헤드 | 큼 | 작음 |
| 사용 예 | HTTP, 채팅 | 실시간 게임 |

---

### 7. 바이트 순서 (Byte Order)

**엔디안 (Endian)**

**Big Endian (빅 엔디안)**
- 상위 바이트가 낮은 주소에 저장
- 네트워크 바이트 순서 (Network Byte Order)
- 사람이 읽기 편함

```
숫자: 0x12345678

메모리:
주소    값
0x00    0x12  ← 상위 바이트
0x01    0x34
0x02    0x56
0x03    0x78  ← 하위 바이트
```

**Little Endian (리틀 엔디안)**
- 하위 바이트가 낮은 주소에 저장
- Intel x86/x64 CPU
- 대부분의 PC

```
숫자: 0x12345678

메모리:
주소    값
0x00    0x78  ← 하위 바이트
0x01    0x56
0x02    0x34
0x03    0x12  ← 상위 바이트
```

**변환 함수**
```csharp
// Host to Network (호스트 → 네트워크)
short networkShort = IPAddress.HostToNetworkOrder(hostShort);
int networkInt = IPAddress.HostToNetworkOrder(hostInt);

// Network to Host (네트워크 → 호스트)
short hostShort = IPAddress.NetworkToHostOrder(networkShort);
int hostInt = IPAddress.NetworkToHostOrder(networkInt);
```

**중요성**
```
클라이언트 (Little Endian)
    │ 송신: 0x12345678
    │       (메모리: 78 56 34 12)
    ▼
네트워크로 전송 시 변환 필요!
    │ 네트워크: 12 34 56 78 (Big Endian)
    ▼
서버 (Little Endian)
    │ 수신 후 변환
    │ 메모리: 78 56 34 12
    ▼
올바른 값: 0x12345678
```

---

### 8. 패킷 (Packet)

**정의**
- 네트워크로 전송되는 데이터의 단위
- 헤더(Header) + 페이로드(Payload)

**구조**
```
┌─────────────────────────────────────┐
│          Ethernet Header            │
├─────────────────────────────────────┤
│            IP Header                │
├─────────────────────────────────────┤
│           TCP/UDP Header            │
├─────────────────────────────────────┤
│          Application Data           │ ← 게임 데이터
│         (Payload/Body)              │
└─────────────────────────────────────┘
```

**TCP 패킷 구조**
```
TCP Header (20바이트 기본)
┌───────────────────────────────────┐
│ Source Port (2 bytes)             │
├───────────────────────────────────┤
│ Destination Port (2 bytes)        │
├───────────────────────────────────┤
│ Sequence Number (4 bytes)         │
├───────────────────────────────────┤
│ Acknowledgment Number (4 bytes)   │
├───────────────────────────────────┤
│ Flags, Window Size... (8 bytes)   │
└───────────────────────────────────┘

Data (가변 길이)
┌───────────────────────────────────┐
│ Application Data                  │ ← 게임 패킷
└───────────────────────────────────┘
```

**게임 패킷 예시**
```
┌──────────────────────────────┐
│ Packet Size (2 bytes)        │ 예: 20
├──────────────────────────────┤
│ Packet ID (2 bytes)          │ 예: 1001 (이동 패킷)
├──────────────────────────────┤
│ Player ID (4 bytes)          │ 예: 12345
├──────────────────────────────┤
│ X Position (4 bytes)         │ 예: 100.5
├──────────────────────────────┤
│ Y Position (4 bytes)         │ 예: 200.3
├──────────────────────────────┤
│ Z Position (4 bytes)         │ 예: 50.7
└──────────────────────────────┘
```

---

### 9. 네트워크 지연 (Latency)

**RTT (Round-Trip Time)**
- 왕복 시간
- 클라이언트 → 서버 → 클라이언트

```
클라이언트                 서버
    │                      │
T0  ├───── 요청 ──────────▶│
    │                      │ T1
    │                      │ (처리)
    │                      │ T2
    │◀───── 응답 ───────────┤
T3  │                      │

RTT = T3 - T0
Latency = (T3 - T0) / 2 (편도)
```

**지연 원인**
1. **전파 지연 (Propagation Delay)**
    - 물리적 거리
    - 빛의 속도 제한

2. **전송 지연 (Transmission Delay)**
    - 패킷 크기 / 대역폭
    - 큰 패킷 = 긴 전송 시간

3. **처리 지연 (Processing Delay)**
    - 라우터, 서버 처리 시간

4. **큐잉 지연 (Queuing Delay)**
    - 라우터 대기 큐

**게임에서의 영향**
```
지연 시간         체감
0-30ms           완벽
30-50ms          양호
50-100ms         보통 (눈에 띔)
100-200ms        나쁨 (렉 느껴짐)
200ms+           매우 나쁨 (플레이 불가)
```

---

### 10. 대역폭 (Bandwidth)

**정의**
- 단위 시간당 전송 가능한 데이터 양
- 단위: bps (bits per second)

**단위 변환**
```
1 Kbps = 1,000 bps
1 Mbps = 1,000 Kbps = 1,000,000 bps
1 Gbps = 1,000 Mbps

주의: 
1 MB/s (MegaByte/second) = 8 Mbps (Megabit/second)
```

**게임 서버 대역폭 계산**
```
예시:
- 100명 동시 접속
- 각 플레이어 초당 10개 패킷
- 각 패킷 100 bytes

초당 패킷: 100명 × 10개 = 1,000개
초당 데이터: 1,000개 × 100 bytes = 100,000 bytes = 100 KB
초당 비트: 100 KB × 8 = 800 Kb = 0.8 Mbps

필요 대역폭: 0.8 Mbps (다운로드) + 0.8 Mbps (업로드)
             = 1.6 Mbps

안전 계수 2배: 3.2 Mbps 권장
```

---

### 핵심 정리

**1. 네트워크 기본**
- IP 주소: 컴퓨터 식별 (192.168.0.1)
- 포트: 프로세스 식별 (7777)
- 소켓: IP + Port (192.168.0.1:7777)

**2. 프로토콜**
- TCP: 신뢰성, 순서 보장 (채팅, 로그인)
- UDP: 빠름, 실시간 (FPS, 위치 동기화)

**3. 데이터 전송**
- 패킷: 데이터 단위 (헤더 + 페이로드)
- 바이트 순서: Big Endian (네트워크), Little Endian (PC)

**4. 성능**
- 지연(Latency): 왕복 시간
- 대역폭(Bandwidth): 초당 전송량

**5. OSI 7계층**
- 게임 서버는 주로 4계층(Transport - TCP/UDP) 사용
- Application 계층에서 게임 로직 처리

---

## Class 20. 통신 모델

### 1. 클라이언트-서버 모델

**구조**
```
┌───────────┐
│ Client 1  │───┐
└───────────┘   │
                │
┌───────────┐   │    ┌──────────┐
│ Client 2  │───┼───▶│  Server  │
└───────────┘   │    └──────────┘
                │
┌───────────┐   │
│ Client 3  │───┘
└───────────┘
```

**특징**
- ✅ 중앙 집중식 관리
- ✅ 보안 용이
- ✅ 데이터 동기화 쉬움
- ❌ 서버 부하 집중
- ❌ 서버 다운 시 전체 마비
- ❌ 확장성 제한

**게임 예시**
- MMORPG (월드 오브 워크래프트)
- 배틀로얄 게임 (포트나이트)
- 대부분의 온라인 게임

---

### 2. P2P (Peer-to-Peer) 모델

**구조**
```
┌─────────┐
│ Peer 1  │◀───────────────┐
└─────────┘                │
    ▲ │                    │
    │ ▼                    │
┌─────────┐                │
│ Peer 2  │◀───────────────┤
└─────────┘                │
    ▲ │                    │
    │ ▼                    │
┌─────────┐                │
│ Peer 3  │────────────────┘
└─────────┘
```

**특징**
- ✅ 서버 부하 없음
- ✅ 확장성 좋음
- ✅ 서버 비용 절감
- ❌ 보안 취약
- ❌ 데이터 동기화 어려움
- ❌ 치트 방지 어려움

**게임 예시**
- 스타크래프트 1 (LAN 모드)
- 카운터 스트라이크 (일부 모드)
- 협동 게임 (2~4인)

---

### 3. 하이브리드 모델

**구조**
```
        ┌──────────┐
        │  Server  │ (매칭, 인증)
        └──────────┘
             │
    ┌────────┼────────┐
    │        │        │
    ▼        ▼        ▼
┌───────┐┌───────┐┌───────┐
│Peer 1 ││Peer 2 ││Peer 3 │
└───────┘└───────┘└───────┘
    ▲        │        │
    │        ▼        │
    └────────┼────────┘
             ▼
       (P2P 통신)
```

**특징**
- 서버: 매칭, 인증, 중요 데이터
- P2P: 실시간 게임 플레이
- 장점 결합

**게임 예시**
- League of Legends (매칭은 서버, 게임은 P2P 비슷)
- Destiny (일부 모드)

---

### 4. 동기 vs 비동기 통신

**동기 통신 (Synchronous)**

```
클라이언트              서버
    │                   │
    ├─── 요청 ─────────▶│
    │   (Blocked)       │
    │                   │ 처리 중...
    │                   │
    │◀─── 응답 ──────────┤
    │ (다음 작업 진행)   │
```

특징:
- 요청 → 대기 → 응답 → 다음 작업
- 간단한 구조
- 응답 대기 중 블로킹

**비동기 통신 (Asynchronous)**

```
클라이언트              서버
    │                   │
    ├─── 요청 ─────────▶│
    │                   │
    ├─── 다른 작업      │ 처리 중...
    │                   │
    ├─── 또 다른 작업   │
    │                   │
    │◀─── 응답 ──────────┤ (콜백/이벤트)
```

특징:
- 요청 후 즉시 다음 작업
- 응답은 나중에 콜백/이벤트로 처리
- 복잡하지만 효율적

**C# 예시**
```csharp
// 동기
byte[] data = socket.Receive(buffer);  // 대기
ProcessData(data);

// 비동기
socket.BeginReceive(buffer, 0, size, SocketFlags.None,
    OnReceiveCallback, null);  // 즉시 반환
// 다른 작업 계속...

void OnReceiveCallback(IAsyncResult ar) {
    byte[] data = socket.EndReceive(ar);
    ProcessData(data);
}
```

---

### 5. Blocking vs Non-Blocking

**Blocking I/O**

```
Thread
  │
  ├──▶ socket.Receive()  ──┐
  │                        │ 대기 (Blocked)
  │                        │ 데이터 올 때까지
  │   ◀─────────────────────┘
  │
  └──▶ 다음 코드 실행
```

특징:
- 데이터가 올 때까지 대기
- 스레드가 블로킹됨
- 간단하지만 비효율적

**Non-Blocking I/O**

```
Thread
  │
  ├──▶ socket.Receive()  ──┐
  │   ◀─────────────────────┘ 즉시 반환 (데이터 없으면 -1)
  │
  ├──▶ 다른 작업
  │
  ├──▶ 다시 Receive() 시도
```

특징:
- 즉시 반환 (데이터 없어도)
- 스레드 블로킹 안 됨
- 폴링 필요 (계속 확인)

---

### 6. 이벤트 기반 모델

**구조**
```
┌────────────────────────────────┐
│      Event Loop (Main)         │
│  while(true) {                 │
│    events = poll();            │
│    foreach(event in events) {  │
│      handle(event);            │
│    }                           │
│  }                             │
└────────────────────────────────┘
         ▲
         │ 이벤트 발생
         │
┌────────┴────────┐
│ 소켓 1: 데이터 도착 │
│ 소켓 2: 연결 요청  │
│ 소켓 3: 에러 발생  │
└─────────────────┘
```

**특징**
- 단일 스레드로 여러 연결 처리
- 이벤트 발생 시에만 처리
- Node.js, Redis 등에서 사용

**Windows: IOCP (I/O Completion Port)**
```
┌──────────────────────────┐
│    IOCP Thread Pool      │
│  ┌─────┐ ┌─────┐ ┌─────┐│
│  │Th 1 │ │Th 2 │ │Th 3 ││
│  └─────┘ └─────┘ └─────┘│
└──────────┬───────────────┘
           │
    ┌──────▼────────┐
    │ Completion    │
    │ Port Queue    │
    │ ┌───────────┐ │
    │ │ Event 1   │ │
    │ │ Event 2   │ │
    │ │ Event 3   │ │
    │ └───────────┘ │
    └───────────────┘
```

특징:
- Windows에서 고성능 네트워크 처리
- 비동기 I/O 완료 통지
- 자동 스레드 풀 관리
- .NET Socket의 기본 방식

**Linux: epoll**
- Linux의 이벤트 기반 I/O
- 많은 연결을 효율적으로 처리

---

### 7. 멀티스레드 vs 싱글스레드 서버

**멀티스레드 서버**

```
┌──────────┐
│ Listener │
└─────┬────┘
      │ 연결 수락
      ▼
┌──────────────────────────┐
│   Thread Pool            │
│ ┌───────┐ ┌───────┐     │
│ │ Th 1  │ │ Th 2  │ ... │
│ │Client1│ │Client2│     │
│ └───────┘ └───────┘     │
└──────────────────────────┘
```

장점:
- ✅ 동시 처리 가능
- ✅ 하나의 클라이언트가 느려도 다른 클라이언트 영향 없음

단점:
- ❌ 동기화 복잡 (lock, race condition)
- ❌ Context Switch 오버헤드
- ❌ 스레드 생성 비용

**싱글스레드 + 비동기**

```
┌────────────────────┐
│   Single Thread    │
│   Event Loop       │
│  ┌──────────────┐  │
│  │ Client 1     │  │
│  │ Client 2     │  │
│  │ Client 3     │  │
│  │ ...          │  │
│  └──────────────┘  │
└────────────────────┘
```

장점:
- ✅ 동기화 불필요
- ✅ Context Switch 없음
- ✅ 메모리 효율적

단점:
- ❌ CPU 바운드 작업에 비효율
- ❌ 하나의 작업이 길면 전체 지연

**게임 서버 선택**
- **멀티스레드**: CPU 바운드 작업 많은 경우 (복잡한 AI, 물리 연산)
- **싱글스레드 + 비동기**: I/O 바운드 작업 중심 (채팅, 간단한 게임)
- **하이브리드**: 실제 대부분의 게임 서버 (멀티스레드 + 비동기 I/O)

---

### 8. 세션 (Session)

**정의**
- 클라이언트와 서버 간의 연결 상태
- 연결 정보, 사용자 데이터 포함

**구조**
```
┌─────────────────────────┐
│       Session           │
├─────────────────────────┤
│ SessionId: 12345        │
│ Socket: [Socket 객체]   │
│ PlayerId: 67890         │
│ IsConnected: true       │
│ LastActivity: DateTime  │
│ SendBuffer: Queue       │
│ RecvBuffer: Queue       │
└─────────────────────────┘
```

**생명주기**
```
1. 연결 수립
   ↓
2. 세션 생성
   ↓
3. 인증/로그인
   ↓
4. 데이터 송수신
   ↓
5. 연결 종료
   ↓
6. 세션 정리
```

---

### 9. 상태 유지 (Stateful) vs 무상태 (Stateless)

**Stateful**
```
클라이언트             서버
    │                 │
    ├─ 1. 로그인 ────▶│ (세션 생성)
    │                 │ Session[123] = User(Alice)
    │                 │
    ├─ 2. 이동 ──────▶│ (세션 확인)
    │   SessionId: 123│ Session[123] → Alice
    │                 │
    ├─ 3. 공격 ──────▶│ (세션 확인)
    │   SessionId: 123│ Session[123] → Alice
```

특징:
- 서버가 클라이언트 상태 기억
- 빠른 처리 (상태 조회)
- 서버 메모리 사용

**Stateless**
```
클라이언트             서버
    │                 │
    ├─ 1. 요청 ──────▶│
    │   Token: xyz123 │ Token 검증
    │                 │ DB 조회
    │                 │
    ├─ 2. 요청 ──────▶│
    │   Token: xyz123 │ Token 검증 (매번)
```

특징:
- 서버가 상태 저장 안 함
- 매 요청마다 인증 정보 포함
- 확장성 좋음 (서버 추가 쉬움)

**게임 서버**
- 실시간 게임: Stateful (세션 유지)
- 웹 API: Stateless (REST API)

---

### 10. 로드 밸런싱 (Load Balancing)

**구조**
```
         클라이언트들
              │
              ▼
    ┌──────────────────┐
    │  Load Balancer   │
    └──────────────────┘
         │   │   │
    ┌────┘   │   └────┐
    ▼        ▼        ▼
┌────────┐┌────────┐┌────────┐
│Server 1││Server 2││Server 3│
└────────┘└────────┘└────────┘
```

**분산 방식**

1. **Round Robin (라운드 로빈)**
```
Client 1 → Server 1
Client 2 → Server 2
Client 3 → Server 3
Client 4 → Server 1
...
```

2. **Least Connections (최소 연결)**
```
Server 1: 10 connections
Server 2: 5 connections  ← 선택
Server 3: 8 connections

새 클라이언트 → Server 2
```

3. **IP Hash**
```
Client IP: 192.168.0.100
Hash(192.168.0.100) % 3 = 1
→ Server 2 (항상 같은 서버)
```

**게임 서버 로드 밸런싱**
```
┌──────────────┐
│ Match Maker  │ (매칭 서버)
└──────────────┘
       │
   ┌───┴───┐
   ▼       ▼
┌─────┐ ┌─────┐
│Room1│ │Room2│ (게임 룸)
│Srv 1│ │Srv 2│
└─────┘ └─────┘
```

---

### 핵심 정리

**1. 통신 모델**
- Client-Server: 중앙 집중, 대부분의 게임
- P2P: 분산, 소규모 멀티플레이어
- Hybrid: 장점 결합

**2. I/O 모델**
- Blocking: 간단, 비효율
- Non-Blocking: 복잡, 효율적
- Async: 콜백 기반, 현대적

**3. 서버 아키텍처**
- 멀티스레드: 동시 처리, 동기화 복잡
- 싱글스레드 + 비동기: 효율적, I/O 바운드 적합
- IOCP/epoll: 고성능 이벤트 기반

**4. 세션**
- Stateful: 상태 유지, 빠름
- Stateless: 확장성, REST API

**5. 확장**
- Load Balancing: 부하 분산
- Horizontal Scaling: 서버 추가

